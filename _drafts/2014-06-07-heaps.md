---
title: Heaps
author: buraktas
layout: post
permalink: /heaps/
dsq_thread_id:
  - 2748468659
categories:
  - Data Structures
tags:
  - data-structures
  - heaps
  - java
  - priority-queues
---
The binary heap data structure is an array object that represents a nearly complete binary tree. Thus, each element of the array corresponds to a node of the tree. Heaps are useful data structures for heapsort ,and they are underlying data structure of priority queues. So for simplicity we can say priority queue is a synonym for a heap. There are two kind of heaps;

<div class="bullet list">
  <ul>
    <li>
      <b>Max-heaps :</b> Returns the maximum element of the collection.
    </li>
    <li>
      <b>Min-heaps :</b> Returns the minimum element of the collection.
    </li>
  </ul>
</div>

This tutorial will continue with min-heaps. Supported operations by a heap is listed below;

<table class="TFtable">
  <tr>
    <th text-align="left">
      Operation
    </th>
    
    <th text-align="left">
      Definition
    </th>
    
    <th text-align="left">
      Time Complexity
    </th>
  </tr>
  
  <tr>
    <td>
      Extract-Min
    </td>
    
    <td>
      Remove an object in heap with a minimum key value.
    </td>
    
    <td>
      \(O(lgn)\)
    </td>
  </tr>
  
  <tr>
    <td>
      Insert
    </td>
    
    <td>
      Add a new object to a heap
    </td>
    
    <td>
      \(O(lgn)\)
    </td>
  </tr>
  
  <tr>
    <td>
      Build-Min-Heap
    </td>
    
    <td>
      Initialize a heap in linear time for a given set.
    </td>
    
    <td>
      \(O(n)\)
    </td>
  </tr>
  
  <tr>
    <td>
      Decrease-Key
    </td>
    
    <td>
      Decreases the key of an existing node to a given value.
    </td>
    
    <td>
      \(O(lgn)\)
    </td>
  </tr>
  
  <tr>
    <td>
      Get-Min
    </td>
    
    <td>
      Return the min key.
    </td>
    
    <td>
      \(O(1)\)
    </td>
  </tr>
</table>

### Heap Property 

<div class="bullet list">
  <ul>
    <li>
      At every node <b>x</b>; Key[x] &nbsp; &le; &nbsp; all keys of <b>x</b>&#8216; s children.
    </li>
    <li>
      Root has the minimum key.
    </li>
  </ul>
</div>

[<img src="http://www.buraktas.com/wp-content/uploads/2014/06/heap_3.png" alt="heap_3" width="792" height="426" class="aligncenter size-full wp-image-330" />][1]

** Parent : **  
parent(i) = i/2 if i is even / \(&lfloor;i/2&rfloor;\) if i is odd

<pre class="lang:java decode:true " >private int parent(int i) {

	if (i % 2 == 1) {
		return i / 2;
	}

	return (i - 1) / 2;
}</pre>

** Left Child : **  
leftChild(i) = 2 * i 

<pre class="lang:java decode:true " >private int left(int i) {

    return 2 * i + 1;
}</pre>

** Right Child : **  
rightChild(i) = 2 * i + 1;

<pre class="lang:java decode:true " >private int right(int i) {

    return 2 * i + 2;
}</pre>

> **Note : **Index calculation of parent, left and right children differs by 1 from source code to formula, this is because I assume formula is based on one-indexed array, and source code (java) uses zero-indexed array.

### Insert and Bubble-Up

Insertion is a straightforward process for heaps, and takes \(O(lgn)\) time. For a given key **k**

<div class="bullet list">
  <ul>
    <li>
      Stick <b>k</b> at end of last level.
    </li>
    <li>
      Bubble-Up <b>k</b> until heap property is restored.( i.e., key of <b>k</b>&#8216; s parent is &le; <b>k</b> )
    </li>
  </ul>
</div>

[<img src="http://www.buraktas.com/wp-content/uploads/2014/06/heap_insert_2.png" alt="heap_insert_2" width="1335" height="535" class="aligncenter size-full wp-image-344" />][2]

The implementation of insert is as follows;

<pre class="lang:java decode:true " >public void insert(int item) {

	list.add(item);
	int i = list.size() - 1;
	int parent = parent(i);

	while (parent != i && list.get(i) &lt; list.get(parent)) {

		swap(i, parent);		
		i = parent;
		parent = parent(i);
	}
}</pre>

### Extract-Min and Bubble-Down 

<div class="bullet list">
  <ul>
    <li>
      Delete last leaf and set it as new root.
    </li>
    <li>
      Iteratively Bubble-Down until heap property is maintained. (always swap with smaller child!)
    </li>
  </ul>
</div>

[<img src="http://www.buraktas.com/wp-content/uploads/2014/06/heap_extract_min.png" alt="heap_extract_min" width="746" height="544" class="aligncenter size-full wp-image-349" />][3]

The *extractMin* procedure uses *minHeapify* subroutine for bubble-down process, and implementation of both of them can be seen below;

<pre class="lang:java decode:true " >public int extractMin() {

	if (list.size() == 0) {

		throw new IllegalStateException("MinHeap is EMPTY");
	} else if (list.size() == 1) {

		int min = list.remove(0);
		return min;
	}

	// remove the last item ,and set it as new root
	int min = list.get(0);
	int lastItem = list.remove(list.size() - 1);
	list.set(0, lastItem);

	// bubble-down until heap property is maintained
	minHeapify(0);

	// return min key
	return min;
}</pre>

<pre class="lang:java decode:true " title="minHeapify" >private void minHeapify(int i) {

	int left = left(i);
	int right = right(i);
	int smallest = -1;

	// find the smallest key between current node and its children.
	if (left &lt;= list.size() - 1 && list.get(left) &lt; list.get(i)) {
		smallest = left;
		} else {
		smallest = i;
	}

	if (right &lt;= list.size() - 1 && list.get(right) &lt; list.get(smallest)) {
		smallest = right;
	}

	// if the smallest key is not the current key then bubble-down it.
	if (smallest != i) {

		swap(i, smallest);
		minHeapify(smallest);
	}
}</pre>

### Build-Min-Heap 

*minHeapify* procedure is used when a heap is initialized from an unordered array in linear time. On the other hand, it is proven that iterating only from middle of the array down to its first element is sufficient to build the heap. The *buildMinHeap* procedure is as follows;

<pre class="lang:java decode:true " >public void buildHeap() {

	for (int i = list.size() / 2; i &gt;= 0; i--) {
		minHeapify(i);
	}
}</pre>

### Decrease Key 

Decreases the key of a node from a given index. So, after decreasing the key of the node the heap property must be maintained, thus node will bubble-up to its correct position. *decrease* procedure is as follow;

<pre class="lang:java decode:true " >public void decreaseKey(int i, int key) {

	if (list.get(i) &lt; key) {
		throw new IllegalArgumentException("Key is larger than the original key");
	}

	list.set(i,key);
	int parent = parent(i);

	// bubble-up until heap property is maintained
	while (i &gt; 0 && list.get(parent) &gt; list.get(i) ) {

	     swap(i, parent);
	     i = parent;
	     parent = parent(parent);
	}
}</pre>

### Get-Min 

Returns the root from heap in \(O(1)\) time. 

<pre class="lang:java decode:true " >public Vertex getMin() {

    return list.get(0);
}</pre>

The whole source code of a min-heap can be seen from [here][4].

 [1]: http://www.buraktas.com/wp-content/uploads/2014/06/heap_3.png
 [2]: http://www.buraktas.com/wp-content/uploads/2014/06/heap_insert_2.png
 [3]: http://www.buraktas.com/wp-content/uploads/2014/06/heap_extract_min.png
 [4]: https://gist.github.com/flexelem/70b120ac9bf2965f419f